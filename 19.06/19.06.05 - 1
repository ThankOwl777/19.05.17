JVM

JVM(Java Virtual Machine)의 메모리 구조
-> 응용 프로그램이 실행되면 시스템이 JVM에게 프로그램을 수행하는데 필요한 메모리를 할당
-> 할당 받은 메모리를 용도에 따라 여러 영역으로 나누어 관리
-> 메서드 영역(Method area), 호출스택(Call stack), 힙(Heap)

메서드 영역(Method area)
-> 프로그램 실행 중 어떤 클래스가 사용
-> JVM이 해당 클래스의 클래스파일(*.class)을 읽어서 분석
-> 클래스에 대한 정보(클래스 데이터)를 Method area에 저장
-> 클래스변수(Class variable)도 함께 생성

힙(Heap)
-> 인스턴스가 생성되는 공간. 인스턴스변수(instance variable)이 생성되는 공간

호출스택(Call stack, execution stack)
-> 메서드의 작업에 필요한 메모리 공간을 제공
-> 메서드가 호출되면 메모리가 할당
-> 할당 메모리는 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용
-> 작업을 마치면 할당되었던 메모리공간은 반환

-> 각 메서드를 위한 메모리상의 작업공간은 서로 구별
-> 첫 번째로 호출된 메서드를 위한 작업공간은 호출스택의 맨 밑에 마련
-> 메서드 수행 중 다른 메서드를 호출하면, 첫 번째 호출 메서드 작업공간 바로 위에 공간이 마련
-> 호출 스택의 특징
  1. 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다
  2. 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다
  3. 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다
  4. 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다
-> 반환타입(return type)이 있는 메서드는 종료되면서 결과 값을 호출한 메서드(caller)에게 반환

--------------------

기본형 매개변수와 참조형 매개변수
-> 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사
-> 기본형(primitive type)일 때는 기본형 값이 복사
-> 참조형(reference type)일 때는 인스턴스의 주소가 복사
-> 기본형 매개변수는 read only, 참조형 매개변수는 read & write

-> 배열도 객체와 같이 참조변수를 통해 데이터가 저장된 공간에 접근
-> 매개변수의 타입이 배열이면, 참조형 매개변수

참조형 반환타입
-> 반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미

재귀호출(recursive call)
-> 메서드 내부에서 메서드 자신을 다시 호출하는 것
-> 재귀호출을 하는 메서드는 '재귀 메서드'
-> void method() {
      method();
   }
-> '메서드 호출'이란 특정 위치에 저장되어 있는 명령들을 수행하는 것

-> 호출된 메서드는 '값에 의한 호출(call by value)'
-> 원래의 값이 아닌 복사된 값으로 작업
-> 호출한 메서드와 관계없이 독립적인 작업수행이 가능

-> 재귀호출뿐이면, 무한반복
-> 재귀호출도 조건문이 필수적
-> void method(int n) {
      if(n == 0)
         return;
      System.out.println(n);
      
      method(--n);
   }
-> n을 1씩 감소시키다가 0이 되면 호출을 중단하는 메서드
-> 대부분의 메서드는 반복문으로 작성하는 것이 가능

-> 매개변수 복사와 종료 후 복귀할 주소저장 등이 필요
-> 반복문보다 재귀호출의 수행시간이 더 길다
-> 재귀호출이 주는 논리적 간결함 때문에 사용

-> 재귀호출만 일어나고 메서드가 종료되지 않으면 '스택오버플로우 에러(StackOverflow Error)' 발생
-> 따라서 '매개변수의 유효성 검사'가 중요

--------------------

