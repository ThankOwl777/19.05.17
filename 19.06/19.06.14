다형성 Polymorphism

다형성
-> 객체지향개념에서 '여러 가지 형태를 가질 수 있는 능력'을 의미

-> 자바에서는 한 타입의 참조변수를 여러 타입의 객체를 참조할 수 있도록 한다
-> 즉, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것
-> 보통 생성된 인스턴스를 다루기 위해서, 인스턴스의 타입과 일치하는 타입의 참조변수만을 사용

-> 같은 타입의 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다

-> 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 허용되지 않는다
-> 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 하기 때문
-> 클래스는 상속을 통해서 확장만 가능
-> 조상 인스턴스 멤버 개수는 자손 인스턴스 멤버 개수보다 항상 적거나 같다

-> 참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정

-> 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다 : 가능
-> 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다 : 불가능

--------------------

참조변수의 형변환
-> 참조변수도 형변환이 가능. 단, 서로 상속관계에 있는 클래스사이에서만 가능
-> 자손타입에서 조상타입으로 형변환은 생략가능
-> 조상타입에서 자손타입으로 형변환은 생략불가

-> 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것을 업캐스팅(up-casting)
-> 조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것을 다운캐스팅(down-casting)

-> 참조변수간의 형변환 역시 캐스트연산자를 사용
-> 괄호()안에 변환하고자 하는 타입의 이름(클래스명)을 작성

-> 조상-자손간의 형변환은 가능하지만, 자손-자손간의 형변환은 불가

-> 형변환은 참조변수의 타입을 변환하는 것. 인스턴스에 아무런 영향을 미치지 않는다
-> 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것

-> 서로 상속관계에 있는 타입간의 형변환은 양뱡향으로 자유롭게 수행 가능
-> 단, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 불가

--------------------

instanceof연산자
-> 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
-> 주로 조건문에 사용.
-> 참조변수 instanceof 타입(클래스명)
-> 연산의 결과는 boolean값인 true 또는 false
-> 실제 인스턴스와 같은 타입 외에 조상타입의 instanceof 연산에도 true를 얻는다
-> true를 얻었다는 것은 검사한 타입으로 형변환이 가능하다는 것

--------------------

참조변수와 인스턴스의 연결
-> 조상클래스에 선언된 멤버변수와 이름이 같은 인스턴스변수를 자손클래스에 정의
-> 조상타입의 참조변수로 참조하는 경우와 자손타입의 참조변수로 참조하는 경우의 결과가 다르다

-> 메서드의 경우 오버라딩한 경우에도 참조변수의 타입에 관계없이 항상 메서드가 호출된다
-> 멤버변수의 경우 참조변수의 타입에 따라 달라진다

-> 멤버변수가 중복으로 정의된 경우
-> 조상타입의 참조변수는 조상 클래스에 선언된 멤버변수가 사용
-> 자손타입의 참조변수는 자손 클래스에 선언된 멤버변수가 사용
-> 중복으로 정의하지 않았을 때는 조상의 멤버들을 사용

--------------------

매개변수의 다형성
-> 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용

--------------------

여러 종류의 객체를 배열로 다루기
-> 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 객체를 배열로 묶어서 다룰 수 있다

-> 배열의 크기 제한이 생길 때 Vector클래스를 사용
-> Vector클래스는 내부적으로 Object타입의 배열을 소유. 배열에 객체를 추가하거나 제거할 수 있게 작성되어 있다
-> 배열의 크기를 자동으로 관리
-> Vector클래스는 동적으로 크기가 관리되는 객체배열

--------------------

