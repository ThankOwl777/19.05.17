Math클래스
-> 기본적인 수학계산에 유용한 메서드로 구성
-> 임의의 수를 얻을 수 있는 random(), 반올림에 사용되는 round() 등등
-> Math클래스의 생성자는 접근 제어자가 private이기 때문에 다른클래스에서 Math인스턴스를 생성할 수 없음
-> 클래스 내에 인스턴스변수가 하나도 없어서 인스턴스를 생성할 필요가 없음
-> Math클래스의 메서드는 모두 static, 2개의 상수만 정의해 놓음
-> public static final double E  = 2.7182818284590452354;  // 자연로그의 밑
-> public static final double PI = 3.14159265358979323846; // 원주율

올림, 버림, 반올림
-> 소수점 n번째 자리에서 반올림한 값을 얻기 위해서는 round()를 사용해야함
-> round()는 항상 소수점 첫째자리에서 반올림을 해서 정수값(long)을 결과로 돌려줌
-> 원하는 자리 수에서 반올림된 값을 얻기 위해서는
  1. 원래 값에 100을 곱한다           ex) 90.6553 * 100 = 9065.53
  2. 결과에 Math.round()를 사용한다       Math.round(9065.53) = 9066
  3. 결과를 다시 100.0으로 나눈다         9066 / 100.0 = 90.66, 9066 / 100 = 90
-> 정수형 간의 연산에서는 반올림이 이루어지지 않음

-> rint()는 round()처럼 소수점 첫 째자리에서 반올림하지만, 반환값이 double임
-> round()와 달리 가장 가까운 짝수값이 됨

--------------------

예외를 발생시키는 메서드
-> 메서드 이름에 'Exact'가 포함된 메서드들이 JDK1.8부터 새로 추가됨
-> 정수형 간의 연산에 발생할 수 있는 오버플로우(overflow)를 감지하기 위한 것
-> int addExact(int x, int y)       // x + y
   int subtractExact(int x, int y)  // x - y
   int multiplyExact(int x, int y)  // x * y
   int incrementExact(int a)        // a++
   int decrementExact(int a)        // a--
   int negateExcat(int a)           // -a
   int toIntExact(long value)       // (int)value - int로의 형변환
-> 연산자는 결과를 반환할 뿐, 오버플로우의 발생여부에 대해 알려주지 않음
-> 위의 메서드들은 오버플로우가 발생하면, 예외(ArithmeticException)를 발생시킴

--------------------
-> negateExact(int a)는 매개변수의 부호를 반대로 바꿔줌
-> 부호를 반대로 바꾸는 식은 '~a+1'
-> '~a'의 결과가 int의 최대값이면, 1을 더하면 오버플로우가 발생
--------------------

StrictMath클래스
-> Math클래스는 최대한의 성능을 얻기 위해 JVM이 설치된 OS의 메서드를 호출해서 사용함
-> 즉, OS에 의존적인 계산을 하고 있는 것
-> OS마다의 차이를 없애기 위해 성능은 다소 포기
-> 대신 어떤 OS에서 실행되도 같은 결과를 얻도록 Math클래스를 새로 작성한 것이 StrictMath클래스

--------------------

Math클래스의 메서드
-> static double abs(double a)
   static float abs(float f)    : 주어진 값의 절대값을 반환함
   static int abs(int f)
   static long abs(long f)
  ex) int    i = Math.abs(-10);
      double d = Math.abs(-10.0);
  => i = 10
     d = 10.0
     
-> static double ceil(double a) : 주어진 값을 올림하여 반환함
  ex) double d  = Math.ceil(10.1);
      double d2 = Math.ceil(-10.1);
      double d3 = Math.ceil(10.000015);
  => d  =  11.0
     d2 = -10.0
     d3 =  11.0
     
-> static double floor(double a) : 주어진 값을 버림하여 반환함
  ex) double d  = Math.floor(10.8);
      double d2 = Math.floor(-10.8);
  => d  =  10.0
     d2 = -11.0
     
-> 
