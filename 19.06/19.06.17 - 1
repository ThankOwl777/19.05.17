인터페이스 interface

인터페이스
-> 인터페이스는 일종의 추상클래스
-> 추상메서드를 갖지만 추상화 정도가 높아 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없음
-> 추상메서드와 상수만을 멤버로 가질 수 있고 다른 요소는 허용하지 않음
-> 추상클래스와 같이 다른 클래스를 작성하는데 도움을 줄 목적으로 작성

인터페이스의 작성
-> 키워드로 interface를 사용
-> 접근제어자로 public 또는 default를 사용
-> interface 인터페이스이름 {
      public static final 타입 상수이름 = 값;
      public abstract 메서드이름(매개변수목록);
   }
-> 인터페이스 멤버들은 제약사항이 있다
  1. 모든 멤버변수는 public static final 이어야 하며, 생략 가능
  2. 모든 메서드는 public abstract 이어야 하며, 생략 가능
-> 생략된 제어자는 컴파일 시 자동으로 추가

--------------------

-> JDK1.8부터 static메서드와 default메서드의 추가를 허용
-> static메서드와 default메서드는 제약이 적용되지 않음

--------------------

인터페이스의 상속
-> 인터페이스로부터만 상속이 가능
-> 클래스와 달리 다중상속이 가능
-> 자손 인터페이스는 조상 인터페이스에 정의된 멤버를 모두 상속받음

-> 인터페이스는 클래스와 달리 Object클래스 같은 최고 조상이 없음

인터페이스의 구현
-> 그 자체로는 인스턴스 생성 불가
-> 자신에게 정의된 추상메서드를 구현해주는 클래스를 작성
-> 구현한다는 의미의 키워드 'implements'를 사용
-> class 클래스이름 implements 인터페이스이름 {
      // 인터페이스에 정의된 추상메서드를 구현
   }
-> 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여 추상클래스로 선언해야 함
-> 상속과 구현을 동시에 할 수도 있음

--------------------

-> 인터페이스는 상속 대신 '구현'이라는 용어를 사용
-> 인터페이스로부터 상속받은 추상메서드를 구현하는 것이기 때문에 다른 의미의 조상

--------------------

인터페이스를 이용한 다중상속
-> 다중상속의 단점이 더 크다고 판단하여 자바에서는 허용하지 않음
-> 허용하지 않는 것이 언어의 단점으로 부각되는 것에 대한 대응으로 지원할 뿐

-> 인터페이스는 static상수만 정의
-> 조상클래스의 멤버변수와 충돌하는 경우는 거의 없음
-> 충돌하더라도 클래스 이름을 붙여서 구분이 가능
-> 추상메서드는 구현부가 없으므로 종상클래스의 메서드와 선언부가 일치할 경우 조상클래스쪽의 메서드를 상속받으면 됨
-> 단, 상속받는 멤버의 충돌은 피할 수 있지만, 다중상속의 장점을 잃게 됨
-> 조상클래스 중 비중이 높은 쪽을 선택
-> 다른 쪽은 클래스 내부 멤버로 포함시키는 방식으로 처리
-> 또는 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현

--------------------

인터페이스를 이용한 다형성
-> 자손클래스의 인스턴스를 조상타입의 참조변수로 참조하는 것이 가능
-> 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있음
-> 인터페이스 타입으로의 형변환도 가능
-> 메서드의 매개변수의 타입으로 사용될 수 있음

-> 인스턴스 타입의 매개변수가 갖는 의미
-> 메서드 호출 시 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것
-> 즉, 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것

--------------------

인터페이스의 장점
1. 개발시간을 단축시킬 수 있다
  -> 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능
  -> 메서드를 호출하는 쪽에서 메서드의 내용에 관계없이 선언부만 알면 되기 때문
  -> 동시에 다른 한 쪽에서 인터페이스 구현 클래스를 작성하면, 동시에 개발을 진행할 수 있음

2. 표준화가 가능하다
  -> 기본 틀을 인터페이스로 작성
  -> 인터페이스를 구현하여 프로그램을 작성하면, 일관되고 정형화된 개발이 가능
  
3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다
  -> 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현
  -> 공통된 인터페이스를 가짐으로써 관계 형성

4. 독립적인 프로그래밍이 가능하다
  -> 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램 작성이 가능
  -> 클래스간의 관계가 간접적이 되면, 한 클래스의 변경이 다른 클래스에 영향을 미치지 않기 때문
  
--------------------

인터페이스의 이해
-> 다음 두 가지 사항을 염두
  1. 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다
  2. 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다

-> 클래스 A(User)와 B(Provider)를 가정
-> A를 작성하려면 B가 작성되어 있어야 함
-> B의 메서드 선언부가 변경되면 사용하는 A도 변경되어야 함
-> 직접적인 관계의 두 클래스는 Provider가 변경되면 User에 영향을 줌

-> 인터페이스 I를 정의
-> A가 I를 통해서 B에 접근하도록하면, B가 수정되어도 A에 영향을 주지 않음
-> A는 오직 직접적인 관계가 있는 I의 영향만 받음

--------------------

디폴트메서드와 static메서드
-> JDK1.8부터 디폴트메서드와 static메서드를 추가할 수 있게 됨

static메서드
-> 인스턴스와 관계 없는 독립적인 메서드이기 때문에 추가하지 못할 이유는 없었음
-> 단지 자바를 배우는데 규칙을 단순히 하기 위해 예외를 두지 않은 것
-> 인터페이스와 관련된 static메서드는 별도의 클래스에 두어야 했음
-> 접근 제어자가 항상 public이며, 생략 가능

디폴트메서드
-> 인터페이스에 메서드를 추가하는 것은, 추상메서드를 추가하는 것
-> 인터페이스를 구현한 모든 클래스들에 메서드를 추가 구현해야 함

-> 디폴트메서드는 추상메서드의 기본적인 구현을 제공하는 메서드
-> 추상메서드가 아니기 때문에 추가되어도 클래스를 변경하지 않아도 됨
-> 키워드 default를 붙이며, 일반메서드처럼 몸통{}이 있어야 함
-> 접근 제어자는 public이며, 생략 가능

-> 디폴트 메서드가 기존 메서드와 이름이 중복되어 충돌하는 경우 해결하는 규칙
  1. 여러 인터페이스의 디폴트 메서드 간의 충돌
    -> 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다
  2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
    -> 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다
    
--------------------

