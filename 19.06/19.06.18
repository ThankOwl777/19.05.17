내부 클래스 inner class

내부클래스
-> 클래스 내에 선언된 클래스
-> AWT나 Swing과 같은 GUI어플리케이션의 이벤트처리 외에는 잘 사용하지 않음
-> 클래스 내에 선언된다는 점을 제외하고 일반적인 클래스와 동일
-> 서로 긴밀한 관계의 클래스들이 사용

-> 두 클래스 멤버 간에 쉽게 접근이 가능
-> 외부에 불필요한 클래스를 감춤으로써 코드를 캡슐화

-> 내부 클래스는 외부 클래스를 제외하고는 다른 클래스에서 잘 사용되지 않는 것이어야 함

내부클래스의 종류와 명칭
-> 변수의 선언위치에 따른 종류와 동일
-> 선언위치에 따라 다음과 같이 구분
  1. 인스턴스 클래스(instance class)
    -> 외부클래스의 멤버변수 선언위치, 인스턴스멤버처럼 다루어짐
    -> 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언

  2. 스태틱 클래스(static class)
    -> 외부클래스의 멤버변수 선언위치, static멤버처럼 다루어짐
    -> 외부클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언
    
  3. 지역 클래스(local class)
    -> 외부클래스의 메서드나 초기화블럭 안에 선언
    -> 선언된 영역 내부에서만 사용가능
  
  4. 익명 클래스(anonymous class)
    -> 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)
    
--------------------

내부클래스의 선언
-> 선언위치에 따라 같은 위치의 변수와 동일한 유효범위(scope)와 접근성(accessibility)를 가짐
-> class 외부클래스 {
      class 인스턴스클래스 {}
      static class 스태틱클래스 {}
      
      void 메서드() {
         class 지역클래스 {}
      }
   }

--------------------

내부클래스의 제어자와 접근성
-> 인스턴스클래스와 스태틱클래스는 외부클래스의 멤버변수(인스턴스변수와 클래스변수)와 같은 위치에 선언
-> 멤버변수와 같은 성질을 가짐
-> 내부클래스를 외부클래스의 멤버와 같이 간주
-> 인스턴스멤버와 static멤버 간의 규칙이 내부클래스에도 똑같이 적용

-> 내부클래스도 클래스이기 때문에 abstract나 final과 같은 제어자 사용 가능
-> 멤버변수처럼 private, protected와 접근제어자도 사용이 가능

-> 내부클래스 중 static클래스만 static멤버를 가질 수 있음
-> final과 static이 동시에 붙은 변수는 상수(cosntant)이므로 모든 내부클래스에서 정의가 가능

-> 인스턴스멤버는 같은 클래스에 있는 인스턴스멤버와 static멤버 모두 직접 호출이 가능
-> static멤버는 인스턴스멤버를 직접 호출할 수 없음

-> 인스턴스클래스는 외부클래스의 인스턴스멤버를 객체생성 없이 바로 사용 가능
-> 스태틱클래스는 외부클래스의 인스턴스멤버를 객체생성 없이 사용할 수 없음

-> 인스턴스클래스는 스태틱클래스의 멤버들을 객체생성 없이 사용할 수 있음
-> 스태틱클래스에서는 인스턴스클래스의 멤버들을 객체생성 없이 사용 불가

--------------------

-> 컴파일 시 생성되는 파일명은 '외부 클래스명$내부 클래스명.class'
-> 지역내부 클래스는 다른 메서드에 같은 이름이 있을 수 있어서 숫자가 붙음

-> 내부클래스와 외부클래스에 선언된 변수의 이름이 같을 때 변수 앞에 'this'를 붙여서 구별
-> 또는 '외부 클래스명.this'를 붙여서 구별 가능

--------------------

익명 클래스(anonymous class)
-> 다른 내부 클래스들과는 달리 이름이 없음
-> 클래스의 선언과 객체의 생성을 동시에 함
-> 한번만 사용될 수 있고 하나의 객체만을 생성할 수 있는 일회용 클래스

-> new 조상클래스이름() {         new 구현인터페이스이름() {
      // 멤버 선언         또는      // 멤버 선언
   }                             }   
-> 이름이 없기 때문에 생성자를 가질 수 없음
-> 조상클래스의 이름이나 구현하고자하는 인터페이스의 이름을 사용해서 정의
-> 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나, 둘 이상의 인터페이스를 구현할 수 없음
-> 하나의 클래스를 상속받거나, 하나의 인터페이스만 구현할 수 있음

-> 이름이 없기 때문에 '외부 클래스명$숫자.class'의 형식으로 파일명이 결정됨

--------------------

