오버라이딩 Overriding

오버라이딩
-> 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
-> 자손 클래스 자신에 맞게 변경해야하는 경우 조상의 메서드를 오버라이딩
-> 메서드의 내용만 새로 작성

조건
-> 메서드의 선언부는 조상의 것과 일치해야 한다
-> 오버라이딩 조건
  1. 이름이 같아야 한다
  2. 매개변수가 같아야 한다
  3. 반환타입이 같아야 한다
-> 즉, 선언부가 서로 일치해야 한다

-> 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 변경 가능

-> 접근 제어자는 조상 클래스의 메서드보다 좁은 범위 불가능
-> 조상 클래스의 메서드가 protected이면 오버라이딩은 protected나 public만 가능
-> 접근 제어자 범위(넓은순) : public > protected > default > private

-> 조상 클래스의 메서드보다 많은 수의 예외 선언 불가능
-> 단순히 선언된 예외의 개수의 문제가 아니라는 것
-> Exception의 경우 모든 예외의 최고 조상이므로 가장 많은 개수의 예외 사용 가능

-> 또 다른 조건
  1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
  2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다
  3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다

--------------------

조상 클래스에 정의된 static메서드를 자손 클래스에서 똑같은 이름의 static메서드로 정의 가능한가
-> 가능. 단 이것은 각 클래스에 별개로 static메서드를 정의한 것. 오버라이딩이 아니다

--------------------

super
-> 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
-> this와 유사
-> 조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 구별해야하는 경우에 사용

-> 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장
-> 이 값이 참조변수인 this와 super의 값

-> static메서드는 인스턴스와 무관
-> this와 마찬가지로 super역시 static메서드에서는 사용 불가

-> 변수만이 아니라 메서드 역시 super를 써서 호출이 가능

super() - 조상 클래스의 생성자
-> this()와 마찬가지로 super() 역시 생성자
-> 조상클래스의 생성자를 호출하는데 사용

-> 자손클래스의 인스턴스를 생성 시, 자손의 멤버와 조상의 멤버가 합쳐진 인스턴스가 생성

-> 생성자의 첫 줄에서 조상클래스의 생성자를 호출
-> 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문

-> 모든 클래스의 최고 조상 Object클래스의 생성자 Object()에서 호출 끝
-> Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자'this()' 또는 'super()'를 호출
-> 그렇지 않으면 컴파일러가 자동적으로 'super();'를 첫 줄에 삽입

-> 인스턴스 생성 시 클래스 선택과 생성자 선택은 중요
  1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
  2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?
  
-> 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야 한다

--------------------

오버로딩 vs. 오버라이딩
-> 오버로딩은 기존에 없는 새로운 메서드를 정의하는 것(new)
-> 오버라이딩은 상속받은 메서드의 내용을 변경하는 것(change, modify)

--------------------

