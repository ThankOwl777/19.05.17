제어자 Modifier

제어자
-> 클래스, 변수 또는 메서드의 선언부에 사용되어 부가적인 의미를 부여
-> 접근 제어자와 그 외의 제어자로 나눌 수 있다
-> 접근 제어자 : public, protected, default, private
-> 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
-> 클래스나 멤버변수와 메서드에 주로 사용, 하나의 대상에 여러 제어자 조합이 가능
-> 단, 접근 제어자는 네 가지 중에서 하나만 가능

--------------------

static - 클래스의, 공통적인
-> 인스턴스 변수는 하나의 클래스로부터 생성되어도 각기 다른 값
-> 클래스 변수(static 변수)는 인스턴스에 관계없이 모두 같은 값
-> 하나의 변수를 모든 인스턴스가 공유하기 때문

-> static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 클래스에 관계된 것
-> 인스턴스를 생성하지 않고도 사용 가능

-> 인스턴스 메서드와 static 메서드의 차이는 메서드 내에서 인스턴스 멤버를 사용하는가의 여부

static 대상에 따른 의미
  1. 멤버변수
  -> 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다
  -> 인스턴스를 생성하지 않고도 사용 가능하다
  -> 클래스가 메모리에 로드될 때 생성된다
  2. 메서드
  -> 인스턴스를 생성하지 않고도 호출이 가능한 static메서드가 된다
  -> static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다

--------------------

final - 마지막의, 변경될 수 없는
-> 거의 모든 대상에 사용 가능
-> 대표적인 클래스로 String과 Math

final 대상에 따른 의미
  1. 클래스
  -> 변경, 확장될 수 없는 클래스가 된다
  -> final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다
  2. 메서드
  -> final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다
  3. 멤버변수, 지역변수
  -> 변수 앞에 final이 붙으면, 값을 변경할 수 없는 '상수'가 된다

생성자를 이용한 final멤버 변수의 초기화
-> 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화되도록 가능
-> 매개변수를 갖는 생성자를 선언, 인스턴스를 생성할 때 생성자의 매개변수로부터 제공받는 것

--------------------

abstract - 추상의, 미완성의
-> 메서드의 선언부만 작성, 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
-> 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'
-> 따라서, 인스턴스 생성이 불가능

abstract 대상에 따른 의미
  1. 클래스
  -> 클래스 내에 추상 메서드가 선언되어 있음을 의미한다
  2. 메서드
  -> 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다
  
java.awt.event.WindowAdapter
-> 완성된 클래스에 abstract를 붙여서 추상클래스로 만드는 경우의 예시
-> 아무런 내용이 없는 메서드들만 정의된 클래스
-> 인스턴스를 생성해봐야 할 수 있는 것이 없으므로 인스턴스 생성을 방지
-> 클래스 자체로는 무쓸모, 다른 클래스가 상속받아 일부 원하는 메서드만 오버라이딩해도 된다는 장점

--------------------

접근 제어자(access modifier)
-> 해당 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
-> 접근제어자가 지정되어 있지 않는다면 default
-> default의 경우 default를 붙이지는 않는다

-> 접근 범위가 넓은 쪽에서 좁은 쪽의 순
   : public > protected > (default) > private
-> public : 접근의 제한이 없다
-> protected : 같은 패키지 내 또는 다른 패키지의 자손클래스에서 접근이 가능
-> default : 같은 패키지 내에서만 접근이 가능
-> private : 같은 클래스 내에서만 접근이 가능

-> 클래스는 public, default만 사용 가능. 메서드, 멤버변수는 모두 가능

접근 제어자를 이용한 캡슐화
-> 클래스의 내부에 선언된 데이터를 보호하기 위해 접근 제어자를 사용
-> 데이터 감추기(data hiding), 객체지향개념의 캡슐화(encapsulation)
-> 내부 작업을 위한 임시 멤버변수나 부분작업을 처리하기 위한 메서드 등을 클래스 내부에 감추기 위해 사용
-> 외부에서 접근할 필요가 없는 멤버들을 숨겨 복잡성을 줄일 수 있다

-> 접근 제어자를 사용하는 이유
  1. 외부로부터 데이터를 보호하기 위해서
  2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

--------------------

-> 보통 멤버변수의 값을 읽는 메서드의 이름은 'get멤버변수이름'
-> 멤버변수의 값을 변경하는 메서드의 이름은 'set멤버변수이름'

--------------------

생성자의 접근 제어자
-> 인스턴스의 생성을 제한
-> 클래스의 접근 제어자와 같지만, 다르게 지정하는 것도 가능
-> private으로 지정하면, 외부 접근으로 인스턴스 생성은 불가능. 하지만 클래스 내부에서는 가능
-> 생성자를 통해 인스턴스의 개수를 제한할 수 있다

-> 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다
-> 자손클래스에서 호출하는 것이 불가능하기 때문
-> final을 붙여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다

--------------------

제어자(modifier)의 조합
-> 각 대상이 사용가능한 제어자
-> 클래스 : public, default, final, abstract
-> 메서드 : 접근제어자, final, abstract, static
-> 멤버변수 : 접근제어자, final, static
-> 지역변수 : final

제어자 조합 사용 시 주의사항
  1. 메서드에 static과 abstract를 함께 사용할 수 없다
  -> static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문
  
  2. 클래스에 abstract와 final을 동시에 사용할 수 없다
  -> 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미
  -> abstract는 상속을 통해 완성되어야 한다는 의미
  -> 서로 모순되므로 동시에 사용할 수 없다
  
  3. abstract메서드의 접근 제어자가 private일 수 없다
  -> abstract메서드는 자손클래스에서 구현해주어야 한다
  -> 접근제어자가 private이면 자손클래스에서 접근이 불가능하다
  
  4. 메서드에 private과 final을 같이 사용할 필요는 없다
  -> private인 메서드는 오버라이딩될 수 없기 때문이다
  -> 둘 중 하나만 사용해도 의미가 충분하다
  
--------------------

