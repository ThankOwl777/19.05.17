산술 연산자

사칙연산자
-> +, -, *, /
-> 우선순위 '*, /, %' > '+, -'

-> 나누기 연산자의 두 피연산자가 int 타입일 경우, 연산결과 역시 int 타입
-> int 타입은 소수점을 저장하지 못하므로 소수점 이하는 버려진다
-> 올바른 연산결과를 위해서는 어느 한 쪽을 실수형으로 형변환 해야한다

-> 피연산자가 정수형인 경우, 나누는 수로 0 사용 불가
-> 0으로 나누면 컴파일은 되지만 실행 시 오류(ArithmeticException)가 발생
-> 부동 소수점값 0.0f, 0.0d로 나누는 것은 가능, 결과는 무한대

-> 연산 순서에 따라서 다른 결과가 발생

-> 사칙연산의 피연사자로 문자도 가능
-> 문자는 유니코드로 바뀌어 저장되므로 정수간의 연산과 동일

-> 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에, 컴파일 시 계산해서 결과로 대체
-> 단, 수식에 변수가 들어가 있는 경우 컴파일러가 미리 계산 불가

-> Math.round()
-> round() 메서드는 매개변수로 받은 값을 소수점 첫째자리에서 반올림하고 그 결과를 정수로 반환

나머지 연산자 %
-> 왼쪽의 피연산자를 오른쪽의 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자
-> 주로 짝수, 홀수 또는 배수 검사 등에 사용
-> 나누는 수로 음수도 허용하지만 부호는 무시
-> 나머지 연산 결과에 왼쪽 피연산자 부호를 붙이면 된다

--------------------

비교 연산자

대소 비교 < > <= >=
-> 두 피연산자의 값의 크기를 비교하는 연산자
-> 결과로 참이면 true, 거짓이면 false를 반환
-> 기본형은 boolean을 제외한 나머지 자료형에 사용 가능, 참조형에는 사용 불가

등가 비교 == !=
-> 두 피연산자의 값이 같은지 다른지를 비교하는 연산자
-> 기본형, 참조형 모두 사용 가능
-> 기본형은 변수에 저장되어 있는 값이 같은지, 참조형은 객체의 주소값을 저장하므로 같은 객체를 가리키는지 알 수 있다
-> 기본형과 참조형 간의 비교는 불가능

-> '='는 대입 연사자이기 때문에 '같다'는 '=='

-> 비교 연산자도 이항 연산자이므로 형변환 사용

문자열의 비교
-> equals() 메서드 사용
-> 비교 연산자는 완전히 같은 것인지 비교, 내용이 같은지 비교하기 위해서는 equals() 사용

-> String은 클래스이므로 new를 사용하여 객체 생성

-> equals()는 객체가 달라도 내용이 같으면 true를 반환
-> 대소문자 구별없이 비교할 때는 equalsIgnoreCase()를 사용

--------------------
