형변환(Casting)
-> 변수 또는 상수의 타입을 다른 타입으로 변환하는 것

형변환 방법
-> (type)피연산자
-> 괄호() = 캐스트 연산자 또는 형변환 연산자
-> 피연산자의 값은 형변환 후에도 아무런 변화가 없다

-> 기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능
-> 기본형과 참조형 간의 형변환은 불가능
-> float을 int로 변환할 때 반올림이 아닌 버림으로 처리

정수형
-> 큰 타입에서 작은 타입으로 변환하는 경우 값 손실(loss of data)이 발생
-> 4byte int에서 1byte byte으로 변환하는 경우 3byte 손실

-> 작은 타입에서 큰 타입으로 변환하는 경우 빈공간은 0 또는 1
-> 보통의 경우 0, 음수의 경우 1

-> Integer.toBinaryString(int i) 메서드 = 10진 정수를 2진 정수로 변환한 문자열 출력

실수형
-> 작은 타입에서 큰 타입으로 변환하는 경우 빈 공간은 0
-> float에서 double의 경우, 지수에서 127을 빼고 1023을 더해서 변환, 가수에서 23자리를 저장하고 빈 공간은 0
-> double에서 float의 경우, 지수에서 1023을 빼고 127을 더해서 변환, 가수에서 52자리 중 23자리만 저장, 나머지는 버린다
-> 단, 24번째 자리의 값이 1이면, 반올림이 발생하여 23자리의 값이 1 증가
-> float의 범위를 넘는 값을 float로 형변환하는 경우 '무한대' 또는 '0'

-> 같은 값을 저장해도 float와 double의 정밀도 차이 때문에 서로 다른 값이 저장
-> 저장할 때 값이 달라졌기 때문에, 형변환을 해도 값이 다르다

정수형을 실수형으로 변환
-> 소수점 이하의 값이 없으므로 비교적 간단
-> 정수를 2진수로 변환, 정규화를 거쳐 실수의 저장형식으로 저장
-> 실수형의 정밀도 제한으로 인한 오차가 발생 할 수 있다

-> int의 최대값은 최대 10자리의 정밀도를 요구, float는 약 7자리의 정밀도를 제공
-> 10진수 8자리 이상의 값을 형변환할 때는 double로 형변환해야 오차가 발생하지 않는다

실수형을 정수형으로 변환
-> 정수형의 표현형식으로 소수점 이하의 값은 표현할 수 없기 때문에 실수형의 소수점이하 값은 버려진다

자동형변환
-> 경우에 따라 편의상의 이유로 형변환 생략 가능
-> 컴파일러가 생략된 형변환을 자동으로 추가
-> 리터럴이 int, 저장하려는 변수가 float의 경우 int 값이 float 범위 내라면 형변환 생략

-> 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 에러 발생
-> 'incompatible types: possible lossy conversion from int to byte'

-> 명시적 형변환의 경우, 컴파일러가 에러를 발생시키지 않는다 ex) char ch = (char)1000;

-> 서로 다른 타입의 연산에서는 연산과정에서 형변환이 발생
-> 표현범위가 더 넓은 타입으로 형변환하여 연산을 수행

자동형변환의 규칙
-> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
-> 표현 가능한 범위 순서
   byte short(char) int long float double
-> short와 char는 2byte로 크기는 같지만, 표현 범위가 달라서 값 손실이 발생할 수 있으므로 자동 형변환이 수행불가

--------------------

1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

